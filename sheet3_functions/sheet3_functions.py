# -*- coding: utf-8 -*-
"""
Created on Tue Nov 15 14:21:43 2016

@author: bec
"""
from __future__ import print_function
from builtins import str
from builtins import zip
import os
import csv
import datetime
import numpy as np
import calendar
from dateutil.relativedelta import relativedelta

import pandas as pd
import xml.etree.ElementTree as ET
import cairosvg

import WA_Hyperloop.becgis as becgis
import WA_Hyperloop.get_dictionaries as gd
from WA_Hyperloop.paths import get_path

def create_sheet3(complete_data, metadata, output_dir):
    
    output_dir = os.path.join(output_dir, metadata['name'], 'sheet3')
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    HIWC_dict = gd.get_hi_and_ec()
    wp_dictionary = dict()
    years = dict()

    LULC = becgis.open_as_array(metadata['lu'], nan_values = True)
    
    for crop in metadata['crops']:
        crop_code = crop[3]
        if crop_code in LULC:
            crop_name = crop[0]
            season_txt = crop[1]
            crop_map = crop[2]
            if crop[4]==None:
                harvest_index = HIWC_dict[crop_name][0]  
                moisture_content = HIWC_dict[crop_name][1]
                aot = HIWC_dict[crop_name][2]
                c3c4 = HIWC_dict[crop_name][3]
            else:
                harvest_index = crop[4][0]
                moisture_content = crop[4][1]
                aot = crop[4][2]
                c3c4 = crop[4][3]
                
            start_dates, end_dates = import_growing_seasons(season_txt)
            # assign seasons to hydrological years
            hydro_years = []
            for h,sd in enumerate(start_dates):
                if sd.month >= metadata['water_year_start_month']:
                    hy = '{0}-{1}'.format(sd.year, sd.year+1)
                else:
                    hy = '{0}-{1}'.format(sd.year, sd.year+1)
                if h == 0:
                    hydro_years=[hy]
                else:
                    hydro_years.extend([hy])
                
            result_seasonly = calc_Y_WP_seasons(start_dates, end_dates, hydro_years, crop_map, crop_code, crop_name, complete_data['etg'][0], complete_data['etg'][1], complete_data['etb'][0], complete_data['etb'][1], complete_data['ndm'][0], complete_data['ndm'][1], os.path.join(output_dir, 'WP_Y_Seasonly_csvs'), harvest_index, moisture_content, aot, c3c4)            
            wp_dictionary[crop_name] = result_seasonly
            
        else:
            print("skipping crop with lu-class {0}, not on LU-map".format(crop_code))
            continue
    years = hydro_years
    
    for year in years:
        csv_fh_b = create_sheet3_csv(wp_dictionary, year, output_dir)
        output_fh_b = csv_fh_b[:-3] + 'pdf'
        create_sheet3_png(metadata['name'], str(year), ['MCM/year', 't/ha/year', 'kg/m3'], csv_fh_b, output_fh_b, template = get_path('sheet3_svg'))
        
    return complete_data


def create_sheet3_csv(wp_y_dictionary, year, output_dir):
    """
    Creates a csv file that can be used to create sheet3b.
    
    Parameters
    ----------
    wp_y_irrigated_dictionary : dict
        Dictionary in which the filehandles pointing to csv-files containing
        the Yield and WP values are specified, as generated by calc_Y_WP_year.
    year : int
        Variable specifying for what year the csv needs to be generated.
    output_dir : str
        String pointing to folder to store results
        
    Returns
    -------
    output_csv_fh_b : str
        Filehandle pointing to the generated output.
        
    Examples
    --------
    >>> results_rice = r'D:\\project_ADB\\Catchments\\VGTB\\sheet3\\Yearly_Yields_WPs_Rice - Irrigated.csv'
    
    >>> wp_y_dictionary = {
            'Cereals': {'-': result_rice},
            'Non-cereals': {'Root/tuber-crops':None, 'Leguminous-crops':None, 'Sugar-crops':None, 'Merged':None},
            'Fruit & vegetables': {'Vegetables&Melons':None, 'Fruits&Nuts':None, 'Merged':None},
            'Oilseeds': {'-': None},
            'Feed crops': {'-': None},
            'Beverage crops': {'-': None},
            'Other crops': {'-': None}}

    """
    output_dir = os.path.join(output_dir, 'sheet3_yearly')
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    output_csv_fh_b = os.path.join(output_dir, 'sheet3_{0}.csv'.format(year))
    
    first_row_b = ["CROP","WATER_CONSUMPTION","LAND_PRODUCTIVITY","WATER_PRODUCTIVITY", "AREA"]
    
    csv_file_b = open(output_csv_fh_b, 'w')
    writer_b = csv.writer(csv_file_b, delimiter=';', lineterminator = '\n')
    writer_b.writerow(first_row_b)
    
    for CROP in wp_y_dictionary:
        df = pd.read_csv(wp_y_dictionary[CROP], delimiter=';')
        df_y = df.loc[df.HydroYear == year]
        
        writer_b.writerow([CROP, float(df_y['WC [km3]']), float(df_y['Yield [kg/ha]']), float(df_y['WP [kg/m3]']), float(df_y['Area [km2]'])])          
    
    csv_file_b.close()
    
    return output_csv_fh_b


def import_growing_seasons(csv_fh):
    """
    Reads an csv file with dates, see example for format of the csv file.
    
    Parameters
    ----------
    csv_fh : str
        Filehandle pointing to csv-file
        
    Returns
    -------
    start_dates : ndarray
        List with datetime.date objects
    end_dates : ndarray
        List with datetime.date object
    
    Examples
    --------
    The csv file should be like:
    >>> Start;End<new_line> 
            04/11/2000;17/02/2001<new_line>
            03/05/2001;02/07/2001<new_line>
            29/11/2001;27/02/2002<new_line>
            etc.   
    """
    start_dates = np.array([])
    end_dates = np.array([])

    with open(csv_fh) as csvfile:
         reader = csv.reader(csvfile, delimiter=';')
         for row in reader:
             if np.all([row[0] != 'Start', row[1] != 'End']):
                 start_dates = np.append(start_dates, datetime.datetime.strptime(row[0], '%d/%m/%Y').date())
                 end_dates = np.append(end_dates, datetime.datetime.strptime(row[1], '%d/%m/%Y').date())
    return start_dates, end_dates

    
def calc_Y_WP_seasons(start_dates, end_dates, hydro_years, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates, output_dir, harvest_index, moisture_content, aot, c3c4):
    """
    Calculate Yields and WPs per season and save results in a csv-file.
    
    Parameters
    ----------
    start_dates : ndarray
        Array with datetime.date objects specifying the startdates of the growing seasons. See ndvi_profiles.py.
    end_dates : ndarray
        Array with datetime.date objects specifying the enddates of the growing seasons. See ndvi_profiles.py.
    lu_fh : str
        Landuse map.
    lu_class : int
        Landuseclass for which to calculate Y and WP.
    croptype : str
        Name of croptype, should be present in HIWC_dict.keys().
    etgreen_fhs : ndarray
        Array with strings pointing to ETgreen maps.
    etgreen_dates : ndarray
        Array with datetime.date objects corresponding to etgreen_fhs.
    etblue_fhs : ndarray
        Array with strings pointing to ETblue maps.
    etblue_dates : ndarray
        Array with datetime.date objects corresponding to etblue_fhs.
    ndm_fhs : ndarray
        Array with strings pointing to Net-Dry-Matter maps.
    ndm_dates : ndarray
        Array with datetime.date objects corresponding to ndm_fhs.
    output_dir : str
        Folder to save results
    HIWC_dict : dict
        Dictionary with Harvest indices and Water Contents, see get_dictionaries.get_hi_and_ec().
        
    Returns
    -------
    csv_filename : str
        Path to newly created csv-file.        
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)    
    
    csv_filename = os.path.join(output_dir, 'Yields_WPs_{0}_{1}.csv'.format(croptype, int(lu_class)))
    csv_file = open(csv_filename, 'w')
    writer = csv.writer(csv_file, delimiter=';', lineterminator = '\n' )
    
    writer.writerow(['HydroYear', "Startdate", "Enddate", "Yield [kg/ha]", "WP [kg/m3]", "WC [km3]", "WC_blue [km3]", "WC_green [km3]", "Area [km2]"])
    for hydroyear, startdate, enddate in zip(hydro_years, start_dates, end_dates):
        Yield, Wp, Wc, Wc_blue, Wc_green, crop_area = calc_Y_WP_season(startdate, enddate, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates,  harvest_index, moisture_content, aot, c3c4, output_dir = output_dir)
        
        writer.writerow([hydroyear, startdate, enddate, Yield, '{:.6f}'.format(Wp), '{:.6f}'.format(Wc), '{:.6f}'.format(Wc_blue), '{:.6f}'.format(Wc_green), '{:.6f}'.format(crop_area)])
    
    csv_file.close()
    return csv_filename

    
def calc_Y_WP_season(startdate, enddate, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates, harvest_index, moisture_content, aot, c3c4, output_dir = None):
    """
    Calculate Yields and WPs for one season.
    
    Parameters
    ----------
    startdate : object
        datetime.date object specifying the startdate of the growing season.
    enddate : ndarray
        datetime.date object specifying the enddate of the growing season.
    lu_fh : str
        Landuse map.
    lu_class : int
        Landuseclass for which to calculate Y and WP.
    croptype : str
        Name of croptype, should be present in HIWC_dict.keys().
    etgreen_fhs : ndarray
        Array with strings pointing to ETgreen maps.
    etgreen_dates : ndarray
        Array with datetime.date objects corresponding to etgreen_fhs.
    etblue_fhs : ndarray
        Array with strings pointing to ETblue maps.
    etblue_dates : ndarray
        Array with datetime.date objects corresponding to etblue_fhs.
    ndm_fhs : ndarray
        Array with strings pointing to Net-Dry-Matter maps.
    ndm_dates : ndarray
        Array with datetime.date objects corresponding to ndm_fhs.
    p_fhs : ndarray
        Array with strings pointing to P maps.
    p_dates : ndarray
        Array with datetime.date objects corresponding to p_fhs.
    output_dir : str
        Folder to save results
    HIWC_dict : dict
        Dictionary with Harvest indices and Water Contents, see get_dictionaries.get_hi_and_ec().
        
    Returns
    -------
    Yield : float
        The yield for the croptype.
    Wp : float
        The waterproductivity for the croptype.
    Wc : float
        The water consumption for the croptype.
    Wc_blue : float
        The blue water consumption for the croptype.
    Wc_green : float
        The green water consumption for the croptype.
    """
    common_dates = becgis.common_dates([etblue_dates, etgreen_dates, ndm_dates])
    

    
    current = datetime.date(startdate.year, startdate.month, 1)
    end_month = datetime.date(enddate.year, enddate.month, 1)
    
    req_dates = np.array([current])
    while current < end_month:
        current = current + relativedelta(months = 1)
        req_dates = np.append(req_dates, current)
    
    season_complete = True
    for date in req_dates:
        season_complete = np.all([season_complete, date in common_dates])
        if not season_complete:
            print("{0} missing in input data, skipping this season".format(date))
            
    if season_complete:
    
        fractions = np.ones(np.shape(req_dates))
        
        start_month_length = float(calendar.monthrange(startdate.year, startdate.month)[1])
        end_month_length = float(calendar.monthrange(enddate.year, enddate.month)[1])
        
        fractions[0] = (start_month_length - startdate.day + 1) / start_month_length
        fractions[-1] = (enddate.day -1) / end_month_length
        
        NDMs = np.stack([becgis.open_as_array(ndm_fhs[ndm_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        NDM = np.nansum(NDMs, axis=2)
        del NDMs
        
        ETGREENs = np.stack([becgis.open_as_array(etgreen_fhs[etgreen_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        ETGREEN = np.nansum(ETGREENs, axis=2)
        del ETGREENs
        
        ETBLUEs = np.stack([becgis.open_as_array(etblue_fhs[etblue_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        ETBLUE = np.nansum(ETBLUEs, axis=2)
        del ETBLUEs
        
        LULC = becgis.open_as_array(lu_fh)
        
        NDM[NDM == 0] = np.nan
        NDM[LULC != lu_class] = ETBLUE[LULC != lu_class] = ETGREEN[LULC != lu_class] =  np.nan
        
        Y = aot * harvest_index * NDM * 22.222 / (1 - moisture_content) * c3c4

        Yield = np.nanmean(Y)
        
        Et_blue = np.nanmean(ETBLUE)
        Et_green = np.nanmean(ETGREEN)
        
        areas = becgis.map_pixel_area_km(lu_fh)
        Wc_blue = np.nansum(ETBLUE / 1000**2 * areas)
        Wc_green = np.nansum(ETGREEN / 1000**2 * areas)
        Wc = Wc_blue + Wc_green
        
        areas[LULC != lu_class] = np.nan
        crop_area = np.nansum(areas)
        print('{0}: {1} km2'.format(croptype, crop_area))
        
        Wp = Yield / ((Et_blue + Et_green) * 10) 
    else:       
        Yield = Wp = Wc = Wc_blue = Wc_green = crop_area = np.nan
        
    return Yield, Wp, Wc, Wc_blue, Wc_green, crop_area



def create_sheet3_png(basin, period, units, data, output, template=False):

    # Read table
    df1 = pd.read_csv(data, sep=';')
    
    # Conversion to get Water consumption in MCM
    unitpow = 3
    df1['WATER_CONSUMPTION'] *= 10**unitpow #conversion to MCM
    df1['LAND_PRODUCTIVITY'] *= 10**-3 #conversion to t/ha
    df1['AREA'] /= 4.2 #conversion to feddan 
    # Data frames
    crop_WC = dict()
    crop_LP = dict()
    crop_WP = dict()
    crop_Area = dict()
    ag_water_cons = 0    
    for c in df1.CROP:
        crop_WC[c] = float(df1.loc[df1.CROP==c].WATER_CONSUMPTION)
        crop_LP[c] = float(df1.loc[df1.CROP==c].LAND_PRODUCTIVITY)
        crop_WP[c] = float(df1.loc[df1.CROP==c].WATER_PRODUCTIVITY)
        crop_Area[c] = float(df1.loc[df1.CROP==c].AREA)
        ag_water_cons += float(df1.loc[df1.CROP==c].WATER_CONSUMPTION)
        
    # write to .svg
    svg_template_path = template
    tree = ET.parse(svg_template_path)
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Titles

    xml_txt_box = tree.findall('''.//*[@id='basin']''')[0]
    list(xml_txt_box)[0].text = 'Basin: ' + basin

    xml_txt_box = tree.findall('''.//*[@id='period']''')[0]
    list(xml_txt_box)[0].text = 'Period: ' + period

    xml_txt_box = tree.findall('''.//*[@id='units']''')[0]
    list(xml_txt_box)[0].text = 'Part 1: Agricultural water consumption (' + units[0] + ')'

    xml_txt_box = tree.findall('''.//*[@id='units-0']''')[0]
    list(xml_txt_box)[0].text = 'Part 2: Land productivity (' + units[1] + ') and water productivity (' + units[2] + ')'

    # Part 1
    p1 = {
        'crop_r01c01' : crop_WC['Wheat'],
        'crop_r01c02' : crop_WC['Winter Vegetables'],
        'crop_r01c03' : crop_WC['Clover'],
        'crop_r01c04' : crop_WC['Winter Other'],
        'crop_r01c05' : crop_WC['Maize'],
        'crop_r01c06' : crop_WC['Rice'],
        'crop_r01c07' : crop_WC['Summer Vegetables'],
        'crop_r01c08' : crop_WC['Oranges'],
        'crop_r01c09' : crop_WC['Summer Other'],
        'crop_r01c10' : crop_WC['Orchards'],
        'crop_r01c11' : crop_WC['Banana'],
        'crop_r01' : ag_water_cons,
        'crop_r02c01' : crop_Area['Wheat'],
        'crop_r02c02' : crop_Area['Winter Vegetables'],
        'crop_r02c03' : crop_Area['Clover'],
        'crop_r02c04' : crop_Area['Winter Other'],
        'crop_r02c05' : crop_Area['Maize'],
        'crop_r02c06' : crop_Area['Rice'],
        'crop_r02c07' : crop_Area['Summer Vegetables'],
        'crop_r02c08' : crop_Area['Oranges'],
        'crop_r02c09' : crop_Area['Summer Other'],
        'crop_r02c10' : crop_Area['Orchards'],
        'crop_r02c11' : crop_Area['Banana'],
            } 
    
    for key in p1:
        if tree.findall(".//*[@id='{0}']".format(key)) != []:
            xml_txt_box = tree.findall(".//*[@id='{0}']".format(key))[0]
            if not pd.isnull(p1[key]):
                list(xml_txt_box)[0].text = '%.0f' % p1[key]
            else:
               list(xml_txt_box)[0].text = '-'    
  
    # Part 2
    
    p2 = {
        'lp_r01c01' : crop_LP['Wheat'],
        'lp_r01c02' : crop_LP['Winter Vegetables'],
        'lp_r01c03' : crop_LP['Clover'],
        'lp_r01c04' : crop_LP['Winter Other'],
        'lp_r01c05' : crop_LP['Maize'],
        'lp_r01c06' : crop_LP['Rice'],
        'lp_r01c07' : crop_LP['Summer Vegetables'],
        'lp_r01c08' : crop_LP['Oranges'],
        'lp_r01c09' : crop_LP['Summer Other'],
        'lp_r01c10' : crop_LP['Orchards'],
        'lp_r01c11' : crop_LP['Banana'],
        }
    
    for key in p2:
        if tree.findall(".//*[@id='{0}']".format(key)) != []:
            xml_txt_box = tree.findall(".//*[@id='{0}']".format(key))[0]
            if not pd.isnull(p2[key]):
                list(xml_txt_box)[0].text = '%.0f' % p2[key]
            else:
               list(xml_txt_box)[0].text = '-'      
    
    p3 = {
        'wp_r01c01' : crop_WP['Wheat'],
        'wp_r01c02' : crop_WP['Winter Vegetables'],
        'wp_r01c03' : crop_WP['Clover'],
        'wp_r01c04' : crop_WP['Winter Other'],
        'wp_r01c05' : crop_WP['Maize'],
        'wp_r01c06' : crop_WP['Rice'],
        'wp_r01c07' : crop_WP['Summer Vegetables'],
        'wp_r01c08' : crop_WP['Oranges'],
        'wp_r01c09' : crop_WP['Summer Other'],
        'wp_r01c10' : crop_WP['Orchards'],
        'wp_r01c11' : crop_WP['Banana'],
            }
    
    for key in p3:
        if tree.findall(".//*[@id='{0}']".format(key)) != []:
            xml_txt_box = tree.findall(".//*[@id='{0}']".format(key))[0]
            if not pd.isnull(p3[key]):
                list(xml_txt_box)[0].text = '%.2f' % p3[key]
            else:
               list(xml_txt_box)[0].text = '-'  

    # Export svg to png
    tempout_path = output.replace('.pdf', '_temporary.svg')
    tree.write(tempout_path)    
    cairosvg.svg2pdf(url=tempout_path, write_to=output)
    cairosvg.svg2png(url=tempout_path, write_to=output.replace('.pdf', '_2.png'))
    os.remove(tempout_path)

    return output
